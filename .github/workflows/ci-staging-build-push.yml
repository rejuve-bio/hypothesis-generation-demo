name: CI - Build, Test and Push All Services (Staging)

on:
  push:
    branches: [ staging ]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [staging]

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}

jobs:
  # SonarQube Code Quality Analysis
  code-quality-analysis:
    runs-on: self-hosted
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov pylint
    
    - name: Run tests with coverage
      env:
        MONGODB_URI: mongodb://localhost:27017
        DB_NAME: test
        OPENAI_API_KEY: dummy-key-for-ci
        ANTHROPIC_API_KEY: dummy-key-for-ci
        HF_TOKEN: dummy-token-for-ci
        JWT_SECRET_KEY: test-secret-key
        JWT_SECRET: test-secret
      run: |
        pytest --cov=. --cov-report=xml --cov-report=html . || echo "No tests found, skipping coverage"
    
    - name: Run pylint
      run: |
        pylint . --output-format=json > pylint-report.json || true
    
    - name: SonarQube Scan
      uses: sonarsource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: http://${{ secrets.HETZNER_IP }}:9000
      with:
        args: >
          -Dsonar.projectKey=hypothesis-generation-demo 
          -Dsonar.sources=. 
          -Dsonar.host.url=http://${{ secrets.HETZNER_IP }}:9000
          -Dsonar.token=${{ secrets.SONAR_TOKEN }}
          -Dsonar.python.pylint.reportPaths=pylint-report.json
          -Dsonar.exclusions=**/venv/**,**/__pycache__/**,**/data/**,**/pl/**,**/prolog_out_ci/**,**/external_data_ci/**,.github/**
    
    - name: SonarQube Quality Gate Check
      uses: sonarsource/sonarqube-quality-gate-action@master
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      continue-on-error: true
    
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-reports
        path: |
          coverage.xml
          htmlcov/
          pylint-report.json

  build-and-test-all:
    needs: [code-quality-analysis]
    if: |
      (github.event_name == 'pull_request') || 
      (github.event_name == 'push')
    runs-on: self-hosted
    
    outputs:
      validation-status: ${{ steps.validate.outcome }}
      docker-pushed: ${{ steps.deployment-trigger.outputs.docker_pushed }}
    
    steps:
    - name: Pre-cleanup workspace
      run: |
        echo "=== Cleaning workspace before checkout ==="
        # Fix permissions from previous run
        docker run --rm -v "$GITHUB_WORKSPACE:/workspace" alpine:latest sh -c "chmod -R 777 /workspace" 2>/dev/null || true
        # Remove old CI resources
        docker compose -f docker-compose.ci.yml down -v 2>/dev/null || true
        echo "[success] Pre-cleanup completed"
        
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    # Secret Scanning with TruffleHog
    - name: TruffleHog Secret Scan
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: ${{ github.event.repository.default_branch }}
        head: HEAD
        extra_args: --debug --only-verified

    - name: Free up disk space
      run: |
        echo "=== Disk space before cleanup ==="
        df -h
        
        echo "=== Cleaning only this workflow's Docker resources ==="
        # Only clean up containers from this specific CI run
        docker container prune -f --filter "label=com.docker.compose.project" || true
        
        echo "=== Disk space after cleanup ==="
        df -h
    
    - name: Check if this is a merge commit (for push events)
      id: check-merge
      run: |
        if [ "${{ github.event_name }}" == "push" ]; then
          if [ $(git rev-list --parents -n 1 HEAD | wc -w) -gt 2 ]; then
            echo "is_merge=true" >> $GITHUB_OUTPUT
            echo "This is a merge commit from a PR"
          else
            echo "is_merge=false" >> $GITHUB_OUTPUT
            echo "This is a direct push, not a merge"
          fi
        else
          echo "is_merge=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Login to Docker Hub
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Create .env file for testing
      run: |
        echo "=== Creating .env file from GitHub Secrets ==="
        
        cat > .env << 'EOF'
        MONGODB_URI=mongodb://mongo:27017
        DB_NAME=default
        OPENAI_API_KEY=sk-test-dummy-key-for-ci-testing-only
        ANTHROPIC_API_KEY=sk-ant-test-dummy-key-for-ci-testing
        HF_TOKEN=hf_dummy_token_for_testing_purposes
        JWT_SECRET_KEY=test-secret-key-for-ci-only-not-production
        JWT_SECRET=test-secret-for-ci-only-not-production
        MONGO_PORT_HOST=27012
        MONGO_PORT_INTERNAL=27017
        PREFECT_PORT_HOST=4223
        PREFECT_PORT_INTERNAL=4200
        PROLOG_PORT_HOST=4262
        PROLOG_PORT_INTERNAL=4242
        FLASK_PORT_HOST=5030
        FLASK_PORT_INTERNAL=5000
        EOF
        
        echo "=== .env file created successfully ==="
        cat .env
        
    - name: Create test docker-compose
      run: |
        echo "=== Creating docker-compose.ci.yml ==="
        cat > docker-compose.ci.yml << 'EOF'
        version: '3.8'
        services:
          mongo:
            image: mongo:latest
            container_name: mongo-ci-staging
            ports:
              - "${MONGO_PORT_HOST}:${MONGO_PORT_INTERNAL}"
            volumes:
              - mongo-data-ci:/data/db
            networks:
              - app_network_ci
          prolog-service:
            container_name: prolog-service-ci-staging
            build:
              context: .
              dockerfile: Dockerfile.prolog
            ports:
              - "${PROLOG_PORT_HOST}:${PROLOG_PORT_INTERNAL}"
            volumes:
              - ./pl:/app/pl
              - ./prolog_out_ci:/mnt/prolog_out_v2
              - ./prolog_out_ci:/mnt/prolog_out_v3
            networks:
              - app_network_ci
          prefect-service:
            container_name: prefect-service-ci-staging
            build:
              context: .
              dockerfile: Dockerfile.prefect
            ports:
              - "${PREFECT_PORT_HOST}:${PREFECT_PORT_INTERNAL}"
            volumes:
              - .:/app
              - prefect-data-ci:/root/.prefect 
            environment:
              - PREFECT_API_URL=http://localhost:${PREFECT_PORT_INTERNAL}/api
              - UV_PROJECT_ENVIRONMENT=/opt/prefect-venv
            env_file:
              - .env
            command: > 
              sh -c "uv run prefect server start --host 0.0.0.0"
            networks:
              - app_network_ci
            
          prefect-deployment:
            container_name: prefect-deployment-ci-staging
            build:
              context: .
              dockerfile: Dockerfile.prefect
            volumes:
              - .:/app
            env_file:
              - .env
            command: >
              sh -c "
              echo 'Waiting for Prefect API to be ready...' &&
              sleep 30 &&
              uv run python deployments.py --ensembl-hgnc-map /app/data/ensembl_to_hgnc.pkl 
              --hgnc-ensembl-map /app/data/hgnc_to_ensembl.pkl 
              --go-map /app/data/go_map.pkl 
              --swipl-host prolog-service 
              --swipl-port ${PROLOG_PORT_INTERNAL}
              "
            environment:
              - PREFECT_API_URL=http://prefect-service:${PREFECT_PORT_INTERNAL}/api
              - UV_PROJECT_ENVIRONMENT=/opt/prefect-venv
            depends_on:
              - prefect-service
            networks:
              - app_network_ci
          flask-app:
            container_name: flask-app-ci-staging
            build:
              context: .
              dockerfile: Dockerfile
            ports:
              - "${FLASK_PORT_HOST}:${FLASK_PORT_INTERNAL}"
            environment:
              - FLASK_ENV=development
              - PREFECT_API_URL=http://prefect-service:${PREFECT_PORT_INTERNAL}/api
            env_file:
              - .env
            volumes:
              - .:/app
              - ./data:/app/data
              - ./external_data_ci:/app/data/external_data
            depends_on:
              - mongo
              - prolog-service
              - prefect-service
            command: >
              sh -c "
              uv run python main.py --ensembl-hgnc-map data/ensembl_to_hgnc.pkl --hgnc-ensembl-map data/hgnc_to_ensembl.pkl \
              --go-map data/go_map.pkl --swipl-host prolog-service --swipl-port ${PROLOG_PORT_INTERNAL}
              "
            networks:
              - app_network_ci
        volumes:
          mongo-data-ci:
          prefect-data-ci:
        networks:
          app_network_ci:
            driver: bridge
        EOF
        
        mkdir -p prolog_out_ci external_data_ci
        echo "=== docker-compose.ci.yml created successfully ==="

    - name: Build and Monitor All Services
      id: validate
      run: |
        set -e
        echo "=== Building and Validating All Services ==="
        echo "Event: ${{ github.event_name }}"
        echo "Action: ${{ github.event.action }}"
        
        echo "=== Building all Docker images ==="
        docker compose -f docker-compose.ci.yml build
        
        echo "=== Starting ALL services ==="
        docker compose -f docker-compose.ci.yml up -d
        
        echo "=== Waiting for services to initialize (90 seconds) ==="
        sleep 90
        
        echo "=== Checking ALL services status ==="
        docker compose -f docker-compose.ci.yml ps
        
        echo ""
        echo "=== Checking individual service health ==="
        
        # Check MongoDB
        echo "--- Checking MongoDB ---"
        if docker compose -f docker-compose.ci.yml ps mongo | grep -q "Up"; then
          echo "[SUCCESS] MongoDB is running"
          echo "=== MongoDB logs (last 5 lines) ==="
          docker compose -f docker-compose.ci.yml logs mongo --tail=5
        else
          echo "[ERROR] MongoDB is NOT running"
          docker compose -f docker-compose.ci.yml logs mongo
          exit 1
        fi
        
        # Check Prolog Service
        echo ""
        echo "--- Checking Prolog Service ---"
        if docker compose -f docker-compose.ci.yml ps prolog-service | grep -q "Up"; then
          echo "[SUCCESS] Prolog Service is running"
          docker compose -f docker-compose.ci.yml logs prolog-service --tail=5
        else
          echo "[ERROR] Prolog Service is NOT running"
          docker compose -f docker-compose.ci.yml logs prolog-service
          exit 1
        fi
        
        # Check Prefect Service
        echo ""
        echo "--- Checking Prefect Service ---"
        if docker compose -f docker-compose.ci.yml ps prefect-service | grep -q "Up"; then
          echo "[SUCCESS] Prefect Service is running"
          docker compose -f docker-compose.ci.yml logs prefect-service --tail=5
        else
          echo "[ERROR] Prefect Service is NOT running"
          docker compose -f docker-compose.ci.yml logs prefect-service
          exit 1
        fi
        
        # Check Prefect Deployment
        echo ""
        echo "--- Checking Prefect Deployment ---"
        docker compose -f docker-compose.ci.yml logs prefect-deployment --tail=20
        echo "[SUCCESS] Prefect Deployment logs retrieved (deployment is one-time setup, exit status doesn't matter)"
                
        # Check Flask App
        echo ""
        echo "--- Checking Flask App ---"
        if docker compose -f docker-compose.ci.yml ps flask-app | grep -q "Up"; then
          echo "[SUCCESS] Flask App is running"
          docker compose -f docker-compose.ci.yml logs flask-app --tail=5
        else
          echo "[ERROR] Flask App is NOT running"
          docker compose -f docker-compose.ci.yml logs flask-app
          exit 1
        fi
        
        echo ""
        echo "=== Final status - All services ==="
        docker compose -f docker-compose.ci.yml ps
        
        echo ""
        echo "[SUCCESS] [SUCCESS] VALIDATION PASSED - ALL services are running and healthy!"

    # Docker Image Size Check
    - name: Check Docker image sizes
      if: steps.validate.outcome == 'success'
      run: |
        echo "=== Checking Docker image sizes ==="
        
        for service in prolog-service prefect-service flask-app; do
          IMAGE_ID=$(docker compose -f docker-compose.ci.yml images -q $service)
          SIZE=$(docker images $IMAGE_ID --format "{{.Size}}")
          echo "$service image size: $SIZE"
        done
        
        echo "[SUCCESS] Image size check completed"

    # Smoke Tests
    - name: Run smoke tests
      if: steps.validate.outcome == 'success'
      run: |
        echo "=== Running smoke tests on critical endpoints ==="
        FLASK_PORT_HOST="${FLASK_PORT_HOST:-5030}"
        
        ENDPOINTS=("/health" "/")
        
        for endpoint in "${ENDPOINTS[@]}"; do
          echo "Testing endpoint: $endpoint"
          if curl -f -s -o /dev/null -w "%{http_code}" http://localhost:${FLASK_PORT_HOST}${endpoint} | grep -q "200\|404"; then
            echo " $endpoint - OK"
          else
            echo " $endpoint - FAILED"
            exit 1
          fi
        done
        
        echo "[SUCCESS] All smoke tests passed!"

    # Tag and Push - only after all checks pass
    - name: Tag and Push Images to Docker Hub
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true' && steps.validate.outcome == 'success'
      run: |
        echo "=== Tagging and pushing images to Docker Hub ==="
        
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        
        # Tag and push each service
        for service in prolog-service prefect-service flask-app prefect-deployment; do
          IMAGE_ID=$(docker compose -f docker-compose.ci.yml images -q $service)
          
          SERVICE_NAME="hypothesis-generation-${service}"
          STAGING_TAG="${{ secrets.DOCKER_HUB_USERNAME }}/${SERVICE_NAME}:staging"
          SHA_TAG="${{ secrets.DOCKER_HUB_USERNAME }}/${SERVICE_NAME}:staging-${SHORT_SHA}"
          LATEST_TAG="${{ secrets.DOCKER_HUB_USERNAME }}/${SERVICE_NAME}:staging-latest"
          
          docker tag $IMAGE_ID $STAGING_TAG
          docker tag $IMAGE_ID $SHA_TAG
          docker tag $IMAGE_ID $LATEST_TAG
          
          docker push $STAGING_TAG
          docker push $SHA_TAG
          docker push $LATEST_TAG
          
          echo "[SUCCESS] $service images pushed"
          echo "  - $STAGING_TAG"
          echo "  - $SHA_TAG (for rollback)"
          echo "  - $LATEST_TAG"
        done
        
        echo "[SUCCESS] All images pushed to Docker Hub"

    # Image Signing with Cosign
    - name: Install Cosign
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true' && steps.validate.outcome == 'success'
      uses: sigstore/cosign-installer@v3
    
    - name: Sign Docker images
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true' && steps.validate.outcome == 'success'
      env:
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      run: |
        echo "=== Signing Docker images ==="
        echo "$COSIGN_PRIVATE_KEY" > /tmp/cosign.key
        
        for service in prolog-service prefect-service flask-app prefect-deployment; do
          SERVICE_NAME="hypothesis-generation-${service}"
          IMAGE_TAG="${{ secrets.DOCKER_HUB_USERNAME }}/${SERVICE_NAME}:staging"
          cosign sign --key /tmp/cosign.key $IMAGE_TAG -y
          echo "[SUCCESS] $service image signed"
        done
        
        rm /tmp/cosign.key
        echo "[SUCCESS] All images signed successfully"

    - name: Set deployment trigger
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true' && steps.validate.outcome == 'success'
      id: deployment-trigger
      run: |
        echo "docker_pushed=true" >> $GITHUB_OUTPUT

    - name: Complete Cleanup
      if: always()
      run: |
        echo "=== Cleaning up CI containers and networks ==="
        
        echo "=== Current running containers before cleanup ==="
        docker compose -f docker-compose.ci.yml ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
        
        # Stop and remove containers
        docker compose -f docker-compose.ci.yml down -v 2>/dev/null || true
        
        # Fix permissions on files created by Docker containers
        docker run --rm -v "$GITHUB_WORKSPACE:/workspace" alpine:latest sh -c "chmod -R 777 /workspace" || true
        
        echo "=== Current running containers after cleanup ==="
        docker compose -f docker-compose.ci.yml ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
        
        echo "=== Cleaning up temporary files ==="
        rm -f docker-compose.ci.yml .env
        
        echo "=== Cleaning Docker system ==="
        docker system prune -f
        
        echo "=== Disk space after cleanup ==="
        df -h
        
        echo "[SUCCESS] Hypothesis Docker resources cleaned up"

    - name: Trigger CD workflow via Repository Dispatch
      if: github.event_name == 'push' && steps.check-merge.outputs.is_merge == 'true' && steps.validate.outcome == 'success'
      run: |
        curl -L -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/${{ github.repository }}/dispatches \
          -d '{"event_type":"deploy-staging","client_payload":{"image_tag":"staging"}}'
        echo "[SUCCESS] CD workflow triggered successfully!"

  # Email Notifications
  notify-success:
    runs-on: self-hosted
    needs: [build-and-test-all]
    if: success() && github.event_name == 'push'
    steps:
    - name: Send success email
      uses: dawidd6/action-send-mail@v3
      with:
        server_address: smtp.gmail.com
        server_port: 587
        username: ${{ secrets.EMAIL_USERNAME }}
        password: ${{ secrets.EMAIL_PASSWORD }}
        subject: "CI Pipeline SUCCESS - Hypothesis Generation"
        to: abdu.kebede@singularitynet.io
        from: GitHub Actions <${{ secrets.EMAIL_USERNAME }}>
        body: |
          CI Pipeline Completed Successfully! [SUCCESS]
          
          Repository: ${{ github.repository }}
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
          
          Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Images pushed:
          - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prolog:staging
          - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-flask:staging
          - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prefect:staging
          - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prefect-deployment:staging

  notify-failure:
    runs-on: self-hosted
    needs: [build-and-test-all]
    if: failure()
    steps:
    - name: Send failure email
      uses: dawidd6/action-send-mail@v3
      with:
        server_address: smtp.gmail.com
        server_port: 587
        username: ${{ secrets.EMAIL_USERNAME }}
        password: ${{ secrets.EMAIL_PASSWORD }}
        subject: "CI Pipeline FAILED - Hypothesis Generation"
        to: abdum14@gmail.com
        from: GitHub Actions <${{ secrets.EMAIL_USERNAME }}>
        body: |
          CI Pipeline Failed! [FAILED]
          
          Repository: ${{ github.repository }}
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
          
          View Logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Please check the workflow logs for details.

  validation-summary:
    runs-on: self-hosted
    needs: build-and-test-all
    if: always()
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Display artifact structure
      run: |
        echo "=== Downloaded Artifacts ==="
        ls -R artifacts/ || echo "No artifacts found"
        
    - name: Summary
      run: |
        echo "=== CI/CD Validation Summary ==="
        echo "Event: ${{ github.event_name }}"
        echo "Validation Status: ${{ needs.build-and-test-all.outputs.validation-status }}"
        
        if [[ "${{ needs.build-and-test-all.outputs.validation-status }}" == "success" ]]; then
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "[SUCCESS] All services built, validated, and pushed to Docker Hub!"
            echo "*** Images:"
            echo "  - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prolog:staging"
            echo "  - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-flask:staging"
            echo "  - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prefect:staging"
            echo "  - ${{ secrets.DOCKER_HUB_USERNAME }}/hypothesis-generation-prefect-deployment:staging"
          else
            echo "[SUCCESS] PR validation passed - ready to merge!"
          fi
        else
          echo "[ERROR] Validation did not pass. Check the build-and-test-all job for details."
          exit 1
        fi